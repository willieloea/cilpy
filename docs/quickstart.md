# How `cilpy` works
## `cilpy` components
The `cilpy` library consists of three components:
 1. A problem generation component (`cilpy.problem`)
 2. A problem solving component (`cilpy.solver`)
 3. A solution comparison component (`cilpy.compare`)

If a user implements the interface defined for each of these components,
`cilpy` can run an experiment, saving effort in studying NIAs.

### `cilpy.problem`
The `cilpy.problem` component is used to generate optimization problems for the
`cilpy.solver` and `cilpy.compare` components.

Currently `cilpy` should allow for the creation of:
 * Constrained Optimization Problems (COPs)
 * Multi-Objective Optimization Problems (MOOPs)

#### Constrained Optimization Problems
There are many ways in which constrained optimization problems (COPs) can be
categorized, but for now `cilpy.problem` categorizes COPs by whether
constraints are static or dynamic, and whether the objective function is static
or dynamic. Thus the following problem categories exist:
 * static constrained static optimization problems (SCSO),
 * static constrained dynamic optimization problems (SCDO),
 * dynamic constrained static optimization problems (DCSO), and
 * dynamic constrained dynamic optimization problems (DCDO).

#### Multi-Objective Optimization Problems
Multi-objective optimization problems (MOOPs) are outside the scope of the
original author's work, and are left as future work. However, the library was
designed with MOOPs in mind, and should allow for the specification of MOOPs.

### `cilpy.solver`
The `cilpy.solver` component is used to solve optimization problems generated
by `cilpy.problem`, and produces output so that `cilpy.compare` can compare
different algorithms.

### `cilpy.compare`
The `cilpy.compare` component is used to compare algorithms defined by
`cilpy.solver` on problems generated by `cilpy.problem`.

#### Comparing solutions
Initially, the library will rely on [other tools](https://github.com/yesteryearer/Automated-Analysis-of-Metaheuristics)
to compare solutions.

# Using `cilpy`
To use `cilpy`, construct a problem that implements the `cilpy/probem`
interface, construct an optimizer/solver that implements the `cilpy/solver`
interface, create a runner instance, and run the runner. Below is a pseudocode
example:
```python
from cilpy.problem import some_problem
from cilpy.solver import some_solver
from cilpy.runner import Runner

if __name__ == '__main__':
    # --- Configure the problem instance ---
    my_problem = some_problem.SomeProblemClass(
        dimension=2
        # Other parameters
    )

    MAX_ITERATIONS = 5000

    # --- Configure the solver ---
    solver_params = {
        'population_size': 30,
        'max_iterations': MAX_ITERATIONS,
        # Other parameters
    }

    # --- Configure and run the experiment ---
    runner = Runner(
        problem=my_problem,
        solver_class=some_solver.SomeSolverClass,
        solver_params=solver_params,
        max_iterations=MAX_ITERATIONS,
        change_frequency=my_problem._change_frequency, # Pass freq to runner
        output_filepath="out.csv"
    )

    runner.run()
```
